.if n .ds Q \&"
.if n .ds U \&"
.if t .ds Q ``
.if t .ds U ''
.TH SCREEN 1 "13 May 1990"
.UC 4
.SH NAME
screen \- screen manager with VT100/ANSI terminal emulation
.SH SYNOPSIS
.B screen
[
.B -options
] [
.B \fIcmd\fP
[
.B \fIargs\fP
] ]
.br
.B screen \-r
[
.BR \fIhost.tty\fP
]
.ta .5i 1.8i
.SH DESCRIPTION
.I Screen
is a full-screen window manager that
multiplexes a physical terminal between several processes (typically
interactive shells).
Each virtual terminal provides the functions
of the DEC VT100 terminal and, in addition, several control functions
from the ANSI X3.64 (ISO 6429) and ISO 2022 standards
(e.\|g. insert/delete line and support for multiple character sets).
.PP
When
.I screen
is called, it creates a single window with a shell in it (or the specified
command) and then gets out of your way so that you can use the program as you
normally would.
Then, at any time, you can create new (full-screen) windows with other programs
in them (including more shells), kill existing windows, view a list of the
current windows, turn output logging on and off, switch between windows
in whatever manner you wish, etc.
When a program terminates,
.I screen
kills the window that contained it.
If this window was in the foreground, the display switches to the previous
window; if none are left,
.I screen
exits.
.PP
Everything you type is sent to the program running in the current window.
The only exception to this is the one keystroke that is used to initiate
a command to the window manager.
By default, each command begins with a control-a (abbreviated C-a from
now on), and is followed by one other keystroke.
The command character and all the key bindings can be fully customized
to be anything you like, though they are always two characters in length.
.PP
The standard way to create a new window is to type \*QC-a c\*U.
This creates a new window running a shell and switches to that
window immediately, regardless of the state of the process running
in the current window.
Similarly, you can create a new window with a custom command in it by
first binding the command to a keystroke (in your .screenrc file) and
then using it just like the \*QC-a c\*U command.
In addition, new windows can be created by running a command like:
.IP
screen emacs prog.c
.PP
from within a previously created window.
This will not run another copy of screen, but will instead supply the
command name and its arguments to the window manager who will use it to
create the new window.
The above example would start the emacs editor (editing prog.c) and switch
to its window.
.PP
If \*Q/etc/utmp\*U is writable by
.IR screen ,
an appropriate record will be written to this file for each window, and
removed when the window is terminated.
This is useful for working with \*Qtalk\*U, \*Qscript\*U,
\*Qshutdown\*U, \*Qrsend\*U, and other similar programs that use the utmp
file to determine who you are.
.SH GETTING STARTED
Before you begin to use
.I screen
you'll need to make sure you have correctly selected your terminal type,
just as you would for any other termcap program.
(You can do this by using
.IR tset ,
for example.)
.PP
If possible, choose a version of your terminal's termcap that has automatic
margins turned \fIoff\fP.
This will ensure an accurate and optimal update of the screen in all
circumstances.
The next best thing is an auto-margin terminal that allows the last position
on the screen to be updated without scrolling the screen (such as a vt100).
This also allows the entire screen to be updated.
Lastly, if all you've got is a \*Qtrue\*U auto-margin terminal
.I screen
will be content to use it, but updating a character put into the last position
on the screen may not be possible until the screen scrolls or the character
is moved into a safe position in some other way.
This delay can be shortened by using a terminal with insert-character
capability.
.PP
If your terminal is of the second type (firm-margined `am'), you will
want to let
.I screen
know about this, since a normal termcap doesn't distinguish this type of
automatic margins from a \*Qtrue\*U `am' terminal.
You do this by specifying the `LP' capability in your termcap
(see the \*Qtermcap\*U .screenrc command), or by using the
.B \-L
command-line option.
.I Screen
needs this information to correctly update the screen.
.PP
If you are using a \*Qtrue\*U auto-margin terminal (no `LP') at low baud
rates, you may want to turn on a more optimal output mode by including the
flag `OP' in your termcap entry, or by specifying the
.B \-O
command-line option.
The trade-off is that
.I screen
will no-longer accurately emulate the vt100's line-end quirks (e.\|g. the
screen will scroll after putting \fIone\fP character in the last screen
position).
.PP
If you're impatient and want to get started without doing a lot more reading,
you should remember this one command:  \*QC-a ?\*U.
Typing these two characters will display a list of the available
.I screen
commands and their bindings.
.SH "COMMAND KEYS"
As mentioned, each
.I screen
command consists of a
\*QC-a\*U followed by a one other character.
For your convenience, all commands that are bound to lower-case letters are
also bound to their control character counterparts (with the exception
of \*QC-a a\*U; see below), thus, \*QC-a c\*U as well as \*QC-a C-c\*U can
be used to create a window.
.PP
The following keystroke commands are available:
.IP "\fBC-a 0\fP  -  \fBC-a 9\fP   (select0 - select9)"
Switch to the window with the number 0 through 9.
When a new window is established, the first available number from the
range 0..9 is assigned to this window.
Thus, the first window can be activated by \*QC-a 0\*U (there can be no more
than 10 windows present at any one time).
.IP "\fBC-a C-a\fP   (other)"
Switch to the window displayed previously.
Note that this function defaults to the command character typed twice,
unless overridden; for instance, if you use the option \*Q\fB\-e]x\fP\*U,
this function becomes \*Q]]\*U, not \*Q]C-a\*U.
.IP "\fBC-a a\fP\0\0\0\0\0"
Send the command character (C-a) to the processes in the current window.
.IP "\fBC-a A\fP   (aka)"
Allow the user to enter an a.\|k.\|a. for the current window.
.IP "\fBC-a c\fP  or  \fBC-a C-c\fP   (shell)"
Create a new window with a shell and switch to that window.
.IP "\fBC-a C\fP   (clear)"
Clear the screen.
.IP "\fBC-a d\fP  or  \fBC-a C-d\fP   (detach)"
Detach
.I screen
(disconnect it from the terminal and put it into the background).
A detached
.I screen
can be resumed by invoking
.I screen
with the
.B \-r
option.
.IP "\fBC-a f\fP  or  \fBC-a C-f\fP   (flow)"
Toggle the current window's flow-control setting.
.IP "\fBC-a h\fP  or  \fBC-a C-h\fP   (hardcopy)"
Write a hardcopy of the current window to the file \*Qhardcopy.\fIn\fP\*U
in the \fIwindow's\fP default directory, where \fIn\fP is the number
of the current window.
.IP "\fBC-a H\fP   (log)"
Begins/ends logging of the current window to the file \*Qscreenlog.\fIn\fP\*U
in the \fIwindow's\fP default directory, where \fIn\fP is the number
of the current window.
The session log is appended to the previous contents of the file
if it already exists.
.IP "\fBC-a i\fP  or  \fBC-a C-i\fP   (info)"
Uses the message line to display some information about the current window:
the cursor position in the form \*Q(column,row)\*U starting with \*U(1,1)\*U,
the terminal width, various flag settings (flow-control, insert mode, origin
mode, wrap mode, application-keypad mode, output logging, and activity
monitoring (`+' indicates enabled, `-' not)),
the currently active character set (\fIG0\fP, \fIG1\fP, \fIG2\fP,
or \fIG3\fP), and the terminal character sets that are currently
designated as \fIG0\fP through \fIG3\fP.
.IP "\fBC-a k\fP  or  \fBC-a C-k\fP   (kill)"
Kill the current window and switch to the previously displayed window.
.IP "\fBC-a l\fP  or  \fBC-a C-l\fP   (redisplay)"
Redisplay the current window.
.IP "\fBC-a L\fP   (login)"
Adds or removes the entry in the /etc/utmp file for the current window.
.IP "\fBC-a m\fP  or  \fBC-a C-m\fP   (lastmsg)"
Repeat the last message displayed in the message line.
Useful if you're typing when a message appears, because (unless your terminal
has a status line) the message goes away when you press a key.
.IP "\fBC-a M\fP   (monitor)"
Toggles monitoring of the current window.
When monitoring is turned on and the affected window is switched into the
background, you will receive the activity notification message in the
status line at the first sign of output and the window will also be marked
with an `@' in the window-status display.
Monitoring is initially off for all windows.
.IP "\fBC-a n\fP  or  \fBC-a C-n\fP  or  \fBC-a space\fP   (next)"
Switch to the next window.
This function can be used repeatedly to cycle through the list of windows.
(Some terminals require you to release the control key before pressing space.)
.IP "\fBC-a p\fP  or  \fBC-a C-p\fP  or  \fBC-a -\fP   (prev)"
Switch to the previous window (the opposite of \fBC-a n\fP).
.IP "\fBC-a q\fP  or  \fBC-a C-q\fP   (xon)"
Send a control-q to the program in the current window.
.IP "\fBC-a r\fP  or  \fBC-a C-r\fP   (wrap)"
Toggle the current window's line-wrap setting (turn the current window's
automatic margins on and off).
.IP "\fBC-a s\fP  or  \fBC-a C-s\fP   (xoff)"
Send a control-s to the program in the current window.
.IP "\fBC-a t\fP  or  \fBC-a C-t\fP   (time)"
Uses the message line to display the time of day, the host name, and the load
averages over 1, 5, and 15 minutes (if this is available on your system).
.IP "\fBC-a v\fP  or  \fBC-a C-v\fP   (version)"
Display the version.
.IP "\fBC-a w\fP  or  \fBC-a C-w\fP   (windows)"
Uses the message line to display a list of all the windows.
Each window is listed by number with the name of process that has been
started in the window (or its a.\|k.\|a.);
the current window is marked with a `*';
the previous window is marked with a `-';
a background window that has received a bell is marked with a `!';
a background window that is being monitored and has had activity occur
is marked with an `@';
a window which has output logging turned on is marked with \*Q(L)\*U.
.IP "\fBC-a W\fP   (width)"
Toggle the window width between 80 and 132 columns.
This requires a capable terminal and the termcap entries \*QZ0\*U and \*QZ1\*U.
See the \*Qtermcap\*U command for more information.
.IP "\fBC-a z\fP  or  \fBC-a C-z\fP   (suspend)"
Suspend
.IR screen .
.IP "\fBC-a Z\fP   (reset)"
Reset the virtual terminal to its \*Qpower-on\*U values.
.IP "\fBC-a .\fP   (termcap)"
Write the termcap entry for the virtual terminal of the currently active
window to the file \*Q.screencap\*U in the user's \*QHOME\*U directory.
This termcap entry is identical to the value of the environment variable
TERMCAP that is set up by
.I screen
for each window.
.IP "\fBC-a /\fP   (autoflow)"
Toggle the current window's autoflow setting between manual and auto.
Autoflow mode assumes that when a program turns on the application keypad
that you want flow-control temporarily turned off (though it is still
possible to toggle flow-control manually).
.IP "\fBC-a ?\fP   (help)"
Displays a help screen showing you all the key bindings.
The first page lists all the internal commands followed by their bindings.
Subsequent pages will display the custom commands, one command per key.
Press space when you're done reading each page, or return to exit early.
All other characters are ignored, except for the command character, which will
exit the help display and begin a command.
.IP "\fBC-a C-\e\fP   (quit)"
Kill all windows and terminate
.IR screen .
.SH "COMMAND-LINE OPTIONS"
Screen has the following command-line options:
.TP 5
.B \-a
include \fIall\fP capabilities (with some minor exceptions) in each
window's termcap, even if
.I screen
must redraw parts of the display in order to implement a function.
.TP 5
.B "\-c \fIfile\fP"
override the default configuration file from \*Q$HOME/.screenrc\*U
to \fIfile\fP.
.TP 5
.B "\-e \fIxy\fP"
specifies the command character to be \fIx\fP and the character generating a
literal command character to \fIy\fP (when typed after the command character).
The default is \*QC-a\*U and `a', which can be specified as \*Q-e^Aa\*U.
See the \*Qescape\*U .screenrc command for more details.
.TP 5
.B "\-f, \-fn, and \-fa"
turns flow-control on, off, or \*Qon with automatic switching\*U.
This can also be defined through the \*Qflow\*U .screenrc command.
.TP 5
.B \-i
will cause the interrupt key (usually C-c) to interrupt the display
immediately when flow-control is on.
See the \*Qflow\*U .screenrc command for details.
.TP 5
.B "\-k \fIname\fP"
sets the a.\|k.\|a. for the default shell or specified program.
See also the \*Qshellaka\*U .screenrc command.
.TP 5
.B "\-l and -ln"
turns login mode on or off (for /etc/utmp updating).
This can also be defined through the \*Qlogin\*U .screenrc command.
.TP 5
.B \-L
tells screen your auto-margin terminal has a writable last-position on
the screen.
This can also be set in your .screenrc by specifying `LP' in a \*Qtermcap\*U
command.
.TP 5
.B \-O
selects a more optimal output mode for your terminal rather than true vt100
emulation (only affects auto-margin terminals without `LP').
This can also be set in your .screenrc by specifying `OP' in a \*Qtermcap\*U
command.
.TP 5
.B "\-r [\fIhost.tty\fP]"
resumes a detached
.I screen
session.
No other options may be specified, though an optional
.I host.tty
may be needed to distinguish between multiple detached
.I screen
sessions.
.TP 5
.B \-R
attempts to resume the first detached screen session it finds.
If successful, all other command-line options are ignored.
If no detached session exists, starts a new session using the specified
options, just as if
.B \-R
were not specified.
.TP 5
.B \-s
sets the default shell to the program specified, instead of the value
in the environment variable SHELL (or \*Q/bin/sh\*U if not defined).
This can also be defined through the \*Qshell\*U .screenrc command.
.SH CUSTOMIZATION
When
.I screen
is invoked, it executes initialization commands from the file
\*Q.screenrc\*U in the user's home directory.
Commands in \*Q.screenrc\*U are used to set options, bind functions to keys,
and to automatically establish one or more extra windows at the beginning of
your
.I screen
session.
Commands are listed one per line, with empty lines being ignored.
A command's arguments are separated by tabs or spaces, and may be
surrounded by single or double quotes.
A `#' turns the rest of the line into a comment, except in quotes.
.PP
The following initialization commands are available:
.PP
.ne 3
.B "activity \fImessage\fP"
.sp
When any activity occurs in a background window that is being monitored,
.I screen
displays a notification in the message line.
The notification message can be re-defined by means of the \*Qactivity\*U
command.
Each occurrence of `%' in \fImessage\fP is replaced by
the number of the window in which activity has occurred,
and each occurrence of `~' is replaced by the definition for bell
in your termcap (usually an audible bell).
The default message is
.sp
	'Activity in window %'
.sp
Note that monitoring is off for all windows by default, but can be altered
by use of the \*Qmonitor\*U command (C-a M).
.PP
.ne 3
.B "autodetach on|off"
.sp
Sets whether \*Qscreen\*U will automatically detach upon hangup, which
saves all your running programs until they are resumed with a
.B "screen -r"
command.
When turned off, a hangup signal will terminate screen and all the processes
it contains.
Autodetach is on by default.
.PP
.ne 3
.B "bell \fImessage\fP"
.sp
When a bell character is sent to a background window,
.I screen
displays a notification in the message line.
The notification message can be re-defined by means of the \*Qbell\*U
command.
Each occurrence of `%' in \fImessage\fP is replaced by
the number of the window to which a bell has been sent,
and each occurrence of `~' is replaced by the definition for bell
in your termcap (usually an audible bell).
The default message is
.sp
	'Bell in window %'
.sp
An empty message can be supplied to the \*Qbell\*U command to suppress
output of a message line (bell "").
.PP
.ne 3
.B "bind \fIkey\fP [\fIfunction\fP [\fIargs\fP]]"
.sp
Bind a function to a key.
By default, each function provided by
.I screen
is bound to one or more keys as indicated by the above table, e.\|g. the
function to create a new window is bound to \*QC-c\*U and \*Qc\*U.
The \*Qbind\*U command can be used to redefine the key bindings and to
define new bindings.
The \fIkey\fP argument is either a single character, a two-character sequence
of the form \*Q^x\*U (meaning \*QC-x\*U), a backslash followed by an octal
number (specifying the ASCII code of the character), or a backslash followed
by a second character, such as \*Q\e^\*U or \*Q\e\e\*U.
The argument can also be quoted, if you like.
If no further argument is given, any previously established binding
for this key is removed.
The \fIfunction\fP argument can be one of the following keywords:
.PP
.nf
	select0	Switch to window #0
	\0\0...
	select9	Switch to window #9
	aka	Change the current window's a.\|k.\|a.
	autoflow	Toggle the current window's autoflow setting
	clear	Clear the screen
	detach	Detach \fIscreen\fP
	flow	Toggle the current window's flow-control setting
	hardcopy	Make hardcopy of current window
	help	Display a list of the key bindings in effect
	info	Display the current window's status information
	kill	Kill the current window
	lastmsg	Redisplay the last message line
	log	Begin/end logging of the current window's output
	login	Toggle the window's \*Qlogin\*U setting (/etc/utmp entry)
	monitor	Toggle activity monitoring of the current window
	next	Switch to the next window
	other	Switch to the window displayed previously
	prev	Switch to the previous window
	quit	Kill all windows and terminate
	redisplay	Redisplay current window
	reset	Reset the window to its \*Qpower-on\*U settings
	screen	Create a new window with the specified command
	shell	Create a new window with a shell
	suspend	Suspend \fIscreen\fP
	termcap	Write screen's termcap entry to $HOME/.screencap
  	version	Display the version numbers and date last modified
	width	Toggle the terminal width between 80 and 132 columns
	windows	Display a list of all windows
	wrap	Toggle the current window's line-wrap setting
	xoff	Send a control-s to the current program
	xon	Send a control-q to the current program
.fi
.PP
For purposes of backward compatibility, if your command does not match one
of the above keywords, it is assumed to be an external command, and is run
in a newly created window.
This is an abbreviation of the screen command,
but without the possibility of specifying any screen options.
Some examples:
.PP
.nf
	bind ' ' windows
	bind ^f screen telnet foobar
	bind \e033 screen -ln -kroot 9 su
.fi
.PP
would bind the space key to the function that displays a list
of windows (so that the function usually invoked by \*QC-a C-w\*U
would also be available as \*QC-a space\*U),
bind \*QC-f\*U to the function \*Qcreate a window with a TELNET
connection to foobar\*U, and bind \*Qescape\*U to the function
that creates an non-login window with a.\|k.\|a. \*Qroot\*U in slot #9, with
a super-user shell.
.PP
.ne 3
.B "chdir [\fIdirectory\fP]"
.sp
Change the \fIcurrent directory\fP of
.I screen
to the specified directory or, if called without an argument,
to your home directory (the value of the environment variable HOME).
All windows that are created by means of the \*Qscreen\*U command
from within \*Q.screenrc\*U or by means of \*QC-a c\*U use this as their
default directory.
Without a chdir command, this would be the directory from which
.I screen
was invoked.
Hardcopy and log files are always written to the \fIwindow's\fP default
directory, \fInot\fP the current directory of the process running in the
window.
You can use this command multiple times in your .screenrc to start various
windows in different default directories, but the last chdir value will
affect all the windows you create interactively.
.PP
.ne 3
.B "escape \fIxy\fP"
.sp
Set the command character to \fIx\fP and the character generating a literal
command character to \fIy\fP (just like in the \-e option).
Each argument is either a single character, a two-character sequence
of the form \*Q^x\*U (meaning \*QC-x\*U), a backslash followed by an octal
number (specifying the ASCII code of the character), or a backslash followed
by a second character, such as \*Q\e^\*U or \*Q\e\e\*U.
The default is \*Q^Aa\*U, but \*Q``\*U is recommended by one of the authors.
.PP
.ne 3
.B "flow on|off|auto [interrupt]"
.sp
Sets the default flow-control mode for new windows.
Specifying \*Qflow auto interrupt\*U is the same as the command-line options
.B \-fa
and
.B \-i.
See the discussion on FLOW-CONTROL later on in this document for full details.
.PP
.ne 3
.B "login on|off"
.sp
Sets the login flag which determines if new windows should have /etc/utmp
entries added for them.
The login state is also changeable on-the-fly by using the bindable version
of the \*Qlogin\*U command (C-a L).
.PP
.ne 3
.B "mode \fImode\fP"
.sp
The mode of each newly allocated pseudo-tty is set to \fImode\fP.
\fIMode\fP is an octal number.
When no \*Qmode\*U command is given, mode 0622 is used.
.PP
.ne 3
.B "screen [\fI-opts\fP] [\fIn\fP] [\fIcmd\fP [\fIargs\fP]]"
.sp
Establish a new window.
The flow-control options
.B (\-f,
.B \-fn
and
.B \-fa),
a.\|k.\|a. option
.B (\-k),
and login options
.B (-l
and
.B -ln)
may be specified for each command.
If an optional number \fIn\fP in the range 0..9 is given, the window
number \fIn\fP is assigned to the newly created window (or, if this
number is already in-use, the next available number).
If a command is specified after \*Qscreen\*U, this command (with the given
arguments) is started in the window; otherwise, a shell is created.
Thus, if your \*Q.screenrc\*U contains the lines
.sp
.nf
	# example for .screenrc:
	screen 1
	screen -fn -k foobar 2 telnet foobar
.fi
.sp
.I screen
creates a shell window (in window #1), a window with a TELNET connection
to the machine foobar (with no flow-control using the a.\|k.\|a. \*Qfoobar\*U
in window #2), and finally, a second shell window
(the default window) which gets a window number of zero.
When the initialization is completed,
.I screen
always switches to the default window, so window #0 would be displayed in this
case.
.PP
.ne 3
.B "shell \fIcommand\fP"
.sp
Set the command to be used to create a new shell.
This overrides the value of the environment variable SHELL, or \*Q/bin/sh\*U
if undefined.
This is useful if you'd like to run a tty-enhancer which is expecting to
execute the program specified in SHELL.
.PP
.ne 3
.B "shellaka \fIa.\|k.\|a.\fP"
.sp
Set the a.\|k.\|a. for all shells created during startup or by
the C-A C-c command.
For details about what a.\|k.\|a.\|'s are, see the discussion
entitled ALSO KNOWN AS.
.PP
.ne 3
.B "termcap \fIterm\fP \fIterminal-tweaks\fP [\fIwindow-tweaks\fP]"
.sp
Use this command to modify your terminal's termcap entry without going through
all the hassles involved in creating a custom termcap entry.
Plus, you can optionally customize the termcap generated for the windows.
.PP
The first argument specifies which terminal(s) should be affected by this
definition.
You can specify multiple terminal names by separating them with `|'s.
Use `*' to match all terminals and `vt*' to match all terminals that begin
with \*Qvt\*U.
.PP
Each \fItweak\fP argument contains one or more termcap defines (separated
by `:'s) to be inserted at the start of the appropriate termcap entry,
enhancing it or overriding existing values.
The first tweak modifies your terminal's termcap, and contains definitions
that your terminal uses to perform certain functions.
Specify a null string to leave this unchanged (e.\|g. '').
The second (optional) tweak modifies all the window termcaps, and must
contain definitions that screen understands (see the VIRTUAL TERMINAL section).
.PP
Some examples:
.IP
termcap xterm*  LP:hs@
.PP
Informs
.I screen
that all terminals that begin with `xterm' have firm auto-margins that
allow the last position on the screen to be updated (LP), but they don't
really have a status line (no 'hs' -- append `@' to turn entries off).
Note that we assume `LP' for all terminal names that start with \*Qvt\*U,
but only if you don't specify a termcap command for that terminal.
.sp
.nf
	termcap vt*  LP
	termcap vt102|vt220  Z0=\eE[?3h:Z1=\eE[?3l
.fi
.sp
Specifies the firm-margined `LP' capability for all terminals that begin with
`vt', and the second line will also add the escape-sequences to switch
into (Z0) and back out of (Z1) 132-character-per-line mode if this is
a vt102 or vt220.
(You must specify Z0 and Z1 in your termcap to use the width-changing
commands.)
.IP
termcap vt100  ""  l0=PF1:l1=PF2:l2=PF3:l3=PF4
.PP
This leaves your vt100 termcap alone and adds the function key labels to
each window's termcap entry.
.IP
termcap h19|z19  am@:im=\eE@:ei=\eEO  dc=\eE[P
.PP
Takes a h19 or z19 termcap and turns off auto-margins (am@) and enables the
insert mode (im) and end-insert (ei) capabilities (the `@' in the `im'
string is after the `=', so it is part of the string).
Having the `im' and `ei' definitions put into your terminal's termcap will
cause screen to automatically advertise the character-insert capability in
each window's termcap.
Each window will also get the delete-character capability (dc) added to its
termcap, which screen will translate into a line-update for the terminal
(we're pretending it doesn't support character deletion).
.PP
If you would like to fully specify each window's termcap entry, you should
instead set the SCREENCAP variable prior to running
.IR screen .
See the discussion on the VIRTUAL TERMINAL in this manual, and the termcap(5)
man page for more information on termcap definitions.
.PP
.ne 3
.B "wrap on|off"
.sp
Sets the line-wrap setting for new windows.
When line-wrap is on, the second consecutive printable character output at
the last column of a line will wrap to the start of the following line.
As an added feature, backspace (^H) will also wrap through the left margin
to the previous line.
Line-wrap is on by default and can be toggled with the \*Qwrap\*U
command (C-a w\*U).
.SH "THE MESSAGE LINE"
.I Screen
displays informational messages and other diagnostics in a \fImessage line\fP
at the bottom of the screen.
If your terminal has a status line defined in its termcap, screen will use
this for displaying its messages, otherwise the last line of the screen will
be temporarily overwritten and output will be momentarily interrupted.
The message line is automatically removed after a few seconds delay, but it
can also be removed early (on terminals without a status line) by beginning
to type.
.PP
The message line facility can be used by an application running in
the current window by means of the ANSI \fIPrivacy message\fP
control sequence.
For instance, from within the shell, try something like:
.IP
echo '<esc>^Hello world<esc>\e\e'
.PP
where '<esc>' is an \fIescape\fP, '^' is a literal up-arrow,
and '\e\e' turns into a single backslash.
.SH "FLOW-CONTROL"
Each window has a flow-control setting that determines how screen deals with
the XON and XOFF characters (and perhaps the interrupt character).
When flow-control is turned off, screen ignores the XON and XOFF characters,
which allows the user to send them to the current program by simply typing
them (useful for the \fIemacs\fP editor, for instance).
The trade-off is that it will take longer for output from a \*Qnormal\*U
program to pause in response to an XOFF.
With flow-control turned on, XON and XOFF characters are used to immediately
pause the output of the current window.
You can still send these characters to the current program, but you must use
the appropriate two-character screen commands (typically \*QC-a q\*U (xon)
and \*QC-a s\*U (xoff)).
The xon/xoff commands are also useful for typing C-s and C-q past a terminal
that intercepts these characters.
.PP
Each window has an initial flow-control value set with either the
.B \-f
option or the \*Qflow\*U .screenrc command.
It can then be toggled on and off interactively with the \*Qflow\*U
bound-command (C-a f).
.PP
There is also an automatic flow-switching mode that will enable/disable
flow-control on-the-fly based on the current setting of the application
keypad -- when it is enabled, flow-control is turned off and visa versa.
Of course, you can still manipulate flow-control manually when needed, and
toggle the auto-flow mode on and off with the \*Qautoflow\*U command (C-a /).
.PP
If you're running with flow-control enabled and find that pressing the
interrupt key (usually C-c) does not interrupt the display until another
6-8 lines have scrolled by, try running screen with the \*Qinterrupt\*U
option (add the \*Qinterrupt\*U flag to the \*Qflow\*U command in
your .screenrc, or use the
.B \-i
command-line option).
This causes the output that
.I screen
has accumulated from the interrupted program to be flushed.
One disadvantage is that the virtual terminal's memory contains the
non-flushed version of the output, which in rare cases can cause
minor inaccuracies in the output.
For example, if you switch screens and return, or update the screen
with \*QC-a l\*U you would see the version of the output you would
have gotten without \*Qinterrupt\*U being on.
Also, you might need to turn off flow-control (or use auto-flow mode to turn
it off automatically) when running a program that expects you to type the
interrupt character as input, as it is possible to interrupt
the output of the virtual terminal to your physical terminal when flow-control
is enabled.
If this happens, a simple refresh of the screen with \*QC-a l\*U will
restore it.
Give each mode a try, and use whichever mode you find more comfortable.
.SH "ALSO KNOWN AS (A.\|K.\|A.\|s)"
You can customize each window's name in the window display (viewed with the
\*Qwindows\*U command (C-a w)) by setting it with one of
the a.\|k.\|a. commands.
Normally the name displayed is the actual command name of the program
created in the window.
However, it is sometimes useful to distinguish various programs of the same
name or to change the name on-the-fly to reflect the current state of
the window.
.PP
The default name for all shell windows can be set with the \*Qshellaka\*U
command in the .screenrc file, while all other windows are created with
a \*Qscreen\*U command and thus can have their name set with the
.B \-k
option.
Interactively, there is the AKA-string escape-sequence
(<esc>k\fIname\fP<esc>\e) and the \*Qaka\*U command (C-a A).
The former can be output from an application to control the window's name
under software control, and the latter will prompt for a name when typed.
You can also bind pre-defined names to keys with the \*Qaka\*U command
to set things quickly without prompting.
.PP
Finally,
.I screen
has a shell-specific heuristic that is enabled by setting the window's name
to \*Q\fIsearch|name\fP\*U and arranging to have a null aka escape-sequence
output as a part of your prompt.
The \fIsearch\fP portion specifies an end-of-prompt search string, while
the \fIname\fP portion specifies the default shell name for the window.
If the \fIname\fP ends in a `:'
.I screen
will add what it believes to be the current command running in the window
to the end of the window's shell name (e.\|g. \*Q\fIname:cmd\fP\*U).
Otherwise the current command name supersedes the shell name while it is
running.
.PP
Here's how it works:  you must modify your shell prompt to output a null
aka escape-sequence (<esc>k<esc>\e) as a part of your prompt.
The last part of your prompt must be the same as the string you specified
for the \fIsearch\fP portion of the a.\|k.\|a.
Once this is set up,
.I screen
will use the aka escape-sequence to clear the previous command name and
get ready for the next command.
Then, when a newline is received from the shell, a search is made for the
end of the prompt.
If found, it will grab the first word after the matched string and use it
as the command name.
If the command name begins with either '!', '%', or '^'
.I screen
will use the first word on the following line (if found) in preference to
the just-found name.
This helps csh users get better command names when using job control or
history recall commands.
.PP
Here's some .screenrc examples:
.IP
screen -k top 2 nice top
.PP
Adding this line to your .screenrc would start a niced version of the
\*Qtop\*U command in window 2 name \*Qtop\*U rather than \*Qnice\*U.
.sp
.nf
	shellaka '> |csh'
	screen 1
.fi
.sp
This file would start two shells (one specified, one default) using
the given shellaka.
The a.\|k.\|a. specified is an auto-aka that would expect the prompt and
the typed command to look something like the following:
.IP
/usr/joe/src/dir> trn
.PP
(it looks after the '> ' for the command name).
The window status would show the name \*Qtrn\*U while the command was
running, and revert to \*Qcsh\*U upon completion.
.IP
bind R screen -k '% |root:' su
.PP
Having this command in your .screenrc would bind the key
sequence \*QC-a R\*U to the \*Qsu\*U command and give it an
auto-aka name of \*Qroot:\*U.
For this auto-aka to work, the screen could look something
like this:
.sp
.nf
	% !em
	emacs file.c
.fi
.sp
Here the user typed the csh history command \*Q!em\*U which ran the
previously entered \*Qemacs\*U command.
The window status would show \*Qroot:emacs\*U during the execution
of the command, and revert to simply \*Qroot:\*U at its completion.
.PP
.nf
	bind o aka
	bind E aka ""
	bind u aka (unknown)
.fi
.sp
The first binding doesn't have any arguments, so it would prompt you
for an a.\|k.\|a. when you type \*QC-a o\*U.
The second binding would clear an auto-aka's current setting (C-a E).
The third binding would set the current window's a.\|k.\|a. to \*Q(unknown)\*U
(C-a u).
.PP
One thing to keep in mind when adding a null aka escape-sequence to
your prompt is that some shells (like the csh) count all the non-control
characters as part of the prompt's length.
If these invisible characters aren't a multiple of 8 then backspacing over
a tab will result in an incorrect display.
One way to get around this is to use a prompt like this:
.IP
set prompt='^[[0000m^[k^[\e% '
.PP
The escape-sequence \*Q<esc>[0000m\*U not only normalizes the character
attributes, but all the zeros round the length of the invisible characters
up to 8.
Bash users will probably want to echo the escape sequence in the
PROMPT_COMMAND:
.IP
PROMPT_COMMAND='echo -n -e "\e033k\e033\e134"'
.PP
(I used \*Q\134\*U to output a `\e' because of a bug in v1.04).
.SH "THE VIRTUAL TERMINAL"
.I Screen
puts several variables into the environment of each process started in a
newly created window:  \*QWINDOW=\fIn\fP\*U (where \fIn\fP is the number
of the respective window), \*QTERM=screen\*U (or \*QTERM=screen-w\*U if
the terminal is wide (132 cols or more)), and a TERMCAP variable
reflecting the capabilities of the virtual terminal emulated by
.IR screen .
The actual set of capabilities supported by the virtual terminal
depends on the capabilities supported by the physical terminal.
If, for instance, the physical terminal does not support underscore mode,
.I screen
does not put the `us' and `ue' capabilities into the window's TERMCAP
variable, accordingly.
However, a minimum number of capabilities must be supported by a
terminal in order to run
.IR screen ;
namely scrolling, clear screen, and direct cursor addressing
(in addition,
.I screen
does not run on hardcopy terminals or on terminals that over-strike).
.PP
Also, you can customize the TERMCAP value used by
.I screen
by using the \*Qtermcap\*U .screenrc command, or
by defining the variable SCREENCAP prior to startup.
When the latter defined, its value will be copied verbatim into each
window's TERMCAP variable.
This can either be the full terminal definition, or a filename where the
terminal \*Qscreen\*U (and/or \*Qscreen-w\*U) is defined.
.PP
When the boolean `G0' capability is present in the termcap entry
for the terminal on which
.I screen
has been called, the terminal emulation of
.I screen
supports multiple character sets.
This allows an application to make use of, for instance,
the VT100 graphics character set or national character sets.
The following control functions from ISO 2022 are supported:
\fIlock shift G0\fP (\fISI\fP), \fIlock shift G1\fP (\fISO\fP),
\fIlock shift G2\fP, \fIlock shift G3\fP, \fIsingle shift G2\fP,
and \fIsingle shift G3\fP.
When a virtual terminal is created or reset, the ASCII character
set is designated as \fIG0\fP through \fIG3\fP.
.PP
When the `po' and `pf' capabilities are present in the terminal's
termcap entry, applications running in a
.I screen
window can send output to the printer port of the terminal.
This allows a user to have an application in one window
sending output to a printer connected to the terminal, while all
other windows are still active (the printer port is enabled
and disabled again for each chunk of output).
As a side-effect, programs running in different windows can
send output to the printer simultaneously.
Data sent to the printer is not displayed in the window.
.PP
Some capabilities are only put into the TERMCAP
variable of the virtual terminal if they can be efficiently
implemented by the physical terminal.
For instance, `dl' (delete line) is only put into the TERMCAP
variable if the terminal supports either delete line itself or
scrolling regions.
.PP
The following is a list of control sequences recognized by
.IR screen .
\*Q(V)\*U and \*Q(A)\*U indicate VT100-specific and ANSI- or
ISO-specific functions, respectively.
.PP
.nf
.TP 20
.B "ESC E"
	Next Line
.TP 20
.B "ESC D"
	Index
.TP 20
.B "ESC M"
	Reverse Index
.TP 20
.B "ESC H"
	Horizontal Tab Set
.TP 20
.B "ESC 7"
(V)	Save Cursor and Attributes
.TP 20
.B "ESC 8"
(V)	Restore Cursor and Attributes
.TP 20
.B "ESC [s"
(A)	Save Cursor and Attributes
.TP 20
.B "ESC [u"
(A)	Restore Cursor and Attributes
.TP 20
.B "ESC c"
	Reset to Initial State
.TP 20
.B "ESC ="
(V)	Application Keypad Mode
.TP 20
.B "ESC >"
(V)	Numeric Keypad Mode
.TP 20
.B "ESC # 8"
(V)	Fill Screen with E's
.TP 20
.B "ESC \e"
(A)	String Terminator
.TP 20
.B "ESC ^"
(A)	Privacy Message String (Message Line)
.TP 20
.B "ESC k"
	A.\|k.\|a. Definition String
.TP 20
.B "ESC P"
(A)	Device Control String
	Outputs a string directly to the host
	terminal without interpretation.
.TP 20
.B "ESC _"
(A)	Application Program Command (not used)
.TP 20
.B "ESC ]"
(A)	Operating System Command (not used)
.TP 20
.B "Control-N"
(A)	Lock Shift G1 (SO)
.TP 20
.B "Control-O"
(A)	Lock Shift G0 (SI)
.TP 20
.B "ESC n"
(A)	Lock Shift G2
.TP 20
.B "ESC o"
(A)	Lock Shift G3
.TP 20
.B "ESC N"
(A)	Single Shift G2
.TP 20
.B "ESC O"
(A)	Single Shift G3
.TP 20
.B "ESC ( Pcs"
(A)	Designate character set as G0
.TP 20
.B "ESC ) Pcs"
(A)	Designate character set as G1
.TP 20
.B "ESC * Pcs"
(A)	Designate character set as G2
.TP 20
.B "ESC + Pcs"
(A)	Designate character set as G3
.TP 20
.B "ESC [ Pn ; Pn H"
	Direct Cursor Addressing
.TP 20
.B "ESC [ Pn ; Pn f"
	Direct Cursor Addressing
.TP 20
.B "ESC [ Pn J"
	Erase in Display
.TP 20
\h'\w'ESC 'u'Pn = None or \fB0\fP
	From Cursor to End of Screen
.TP 20
\h'\w'ESC 'u'\fB1\fP
	From Beginning of Screen to Cursor
.TP 20
\h'\w'ESC 'u'\fB2\fP
	Entire Screen
.TP 20
.B "ESC [ Pn K"
	Erase in Line
.TP 20
\h'\w'ESC 'u'Pn = None or \fB0\fP
	From Cursor to End of Line
.TP 20
\h'\w'ESC 'u'\fB1\fP
	From Beginning of Line to Cursor
.TP 20
\h'\w'ESC 'u'\fB2\fP
	Entire Line
.TP 20
.B "ESC [ Pn A"
	Cursor Up
.TP 20
.B "ESC [ Pn B"
	Cursor Down
.TP 20
.B "ESC [ Pn C"
	Cursor Right
.TP 20
.B "ESC [ Pn D"
	Cursor Left
.TP 20
.B "ESC [ Ps ;...; Ps m"
	Select Graphic Rendition
.TP 20
\h'\w'ESC 'u'Ps = None or \fB0\fP
	Default Rendition
.TP 20
\h'\w'ESC 'u'\fB1\fP
	Bold
.TP 20
\h'\w'ESC 'u'\fB2\fP
(A)	Faint
.TP 20
\h'\w'ESC 'u'\fB3\fP
(A)	\fIStandout\fP Mode (ANSI: Italicized)
.TP 20
\h'\w'ESC 'u'\fB4\fP
	Underlined
.TP 20
\h'\w'ESC 'u'\fB5\fP
	Blinking
.TP 20
\h'\w'ESC 'u'\fB7\fP
	Negative Image
.TP 20
\h'\w'ESC 'u'\fB22\fP
(A)	Normal Intensity
.TP 20
\h'\w'ESC 'u'\fB23\fP
(A)	\fIStandout\fP Mode off (ANSI: Italicized off)
.TP 20
\h'\w'ESC 'u'\fB24\fP
(A)	Not Underlined
.TP 20
\h'\w'ESC 'u'\fB25\fP
(A)	Not Blinking
.TP 20
\h'\w'ESC 'u'\fB27\fP
(A)	Positive Image
.TP 20
.B "ESC [ Pn g"
	Tab Clear
.TP 20
\h'\w'ESC 'u'Pn = None or \fB0\fP
	Clear Tab at Current Position
.TP 20
\h'\w'ESC 'u'\fB3\fP
	Clear All Tabs
.TP 20
.B "ESC [ Pn ; Pn r"
(V)	Set Scrolling Region
.TP 20
.B "ESC [ Pn I"
(A)	Horizontal Tab
.TP 20
.B "ESC [ Pn Z"
(A)	Backward Tab
.TP 20
.B "ESC [ Pn L"
(A)	Insert Line
.TP 20
.B "ESC [ Pn M"
(A)	Delete Line
.TP 20
.B "ESC [ Pn @"
(A)	Insert Character
.TP 20
.B "ESC [ Pn P"
(A)	Delete Character
.TP 20
.B "ESC [ Ps  ;...; Ps h"
	Set Mode
.TP 20
.B "ESC [ Ps  ;...; Ps l"
	Reset Mode
.TP 20
\h'\w'ESC 'u'Ps = \fB4\fP
(A)	Insert Mode
.TP 20
\h'\w'ESC 'u'\fB?3\fP
(V)	Change Terminal Width
.TP 20
\h'\w'ESC 'u'\fB?5\fP
(V)	Visible Bell (\fIOn\fP followed by \fIOff\fP)
.TP 20
\h'\w'ESC 'u'\fB?6\fP
(V)	\fIOrigin\fP Mode
.TP 20
\h'\w'ESC 'u'\fB?7\fP
(V)	\fIWrap\fP Mode
.TP 20
.B "ESC [ 5 i"
(A)	Start relay to printer (ANSI Media Copy)
.TP 20
.B "ESC [ 4 i"
(A)	Stop relay to printer (ANSI Media Copy)
.fi
.SH FILES
.nf
.ta 2i
$(HOME)/.screenrc	\fIscreen\fP initialization commands
.br
$(HOME)/.screen	Directory created by \fIscreen\fP
.br
$(HOME)/.screen/\fIhost.tty\fP Socket created by \fIscreen\fP
.br
/usr/tmp/S-<login> Alternate directory for some NFS systems
.br
/usr/tmp/S-<login>/\fIhost.tty\fP Alternate socket for some NFS systems
.br
hardcopy.[0-9]	Screen images created by the hardcopy function
.br
screenlog.[0-9]	Output log files created by the log function
.br
$HOME/.screencap	Written by the \*Qtermcap\*U output function
.br
/etc/termcap	Terminal capability database
.br
/etc/utmp	Login records
.fi
.SH "SEE ALSO"
termcap(5), utmp(5)
.SH AUTHORS
Originally created by Oliver Laumann, this latest version was
produced by Wayne Davison.
.SH CONTRIBUTORS
Bart Schaefer,
Patrick Wolfe,
Nathan Glasser,
Larry Virden
.SH BUGS
Standout mode is not cleared before newline or cursor addressing.
.PP
The VT100 \*Qwrap around with cursor addressing\*U bug is not compensated
when
.I screen
is running on a VT100.
.PP
`dm' (delete mode), `xn', and `xs' are not handled
correctly (they are ignored).
.PP
The \fIGR\fP set of ISO 2022 is not supported.
.PP
Scrolling regions are only emulated if the physical terminal supports
scrolling regions.
.PP
.I Screen
does not make use of hardware tabs.
.PP
.I Screen
must be installed as set-uid with owner root in order to be able
to correctly change the owner of the tty device file for each
window.
Special permission may also be required to write the file \*Q/etc/utmp\*U.
.PP
Entries in \*Q/etc/utmp\*U are not removed when
.I screen
is killed with SIGKILL.
This will cause some programs (like "w" or "rwho")
to advertise that a user is logged on who really isn't.
